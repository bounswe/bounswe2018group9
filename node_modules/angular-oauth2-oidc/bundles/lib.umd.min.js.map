{
  "version": 3,
  "file": "lib.umd.min.js",
  "sources": [
    "ng://lib/node_modules/tslib/tslib.es6.js",
    "ng://lib/out/types.ts",
    "ng://lib/out/token-validation/validation-handler.ts",
    "ng://lib/out/url-helper.service.ts",
    "ng://lib/out/events.ts",
    "ng://lib/out/base64-helper.ts",
    "ng://lib/out/auth.config.ts",
    "ng://lib/out/encoder.ts",
    "ng://lib/out/oauth-service.ts",
    "ng://lib/out/oauth-module.config.ts",
    "ng://lib/out/interceptors/resource-server-error-handler.ts",
    "ng://lib/out/interceptors/default-oauth.interceptor.ts",
    "ng://lib/out/token-validation/null-validation-handler.ts",
    "ng://lib/out/angular-oauth-oidic.module.ts",
    "ng://lib/out/token-validation/jwks-validation-handler.ts",
    "ng://lib/out/tokens.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "/**\r\n * Additional options that can be passt to tryLogin.\r\n */\r\nexport class LoginOptions {\r\n  /**\r\n   * Is called, after a token has been received and\r\n   * successfully validated.\r\n   *\r\n   * Deprecated:  Use property ``events`` on OAuthService instead.\r\n   */\r\n  onTokenReceived?: (receivedTokens: ReceivedTokens) => void;\r\n\r\n  /**\r\n   * Hook, to validate the received tokens.\r\n   * Deprecated:  Use property ``tokenValidationHandler`` on OAuthService instead.\r\n   */\r\n  validationHandler?: (receivedTokens: ReceivedTokens) => Promise<any>;\r\n\r\n  /**\r\n   * Called when tryLogin detects that the auth server\r\n   * included an error message into the hash fragment.\r\n   *\r\n   * Deprecated:  Use property ``events`` on OAuthService instead.\r\n   */\r\n  onLoginError?: (params: object) => void;\r\n\r\n  /**\r\n   * A custom hash fragment to be used instead of the\r\n   * actual one. This is used for silent refreshes, to\r\n   * pass the iframes hash fragment to this method.\r\n   */\r\n  customHashFragment?: string;\r\n\r\n  /**\r\n   * Set this to true to disable the oauth2 state\r\n   * check which is a best practice to avoid\r\n   * security attacks.\r\n   * As OIDC defines a nonce check that includes\r\n   * this, this can be set to true when only doing\r\n   * OIDC.\r\n   */\r\n  disableOAuth2StateCheck?: boolean;\r\n\r\n  /**\r\n   * Normally, you want to clear your hash fragment after\r\n   * the lib read the token(s) so that they are not displayed\r\n   * anymore in the url. If not, set this to true.\r\n   */\r\n  preventClearHashAfterLogin? = false;\r\n}\r\n\r\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\r\nexport abstract class OAuthStorage {\r\n  abstract getItem(key: string): string | null;\r\n  abstract removeItem(key: string): void;\r\n  abstract setItem(key: string, data: string): void;\r\n}\r\n\r\n/**\r\n * Represents the received tokens, the received state\r\n * and the parsed claims from the id-token.\r\n */\r\nexport class ReceivedTokens {\r\n  idToken: string;\r\n  accessToken: string;\r\n  idClaims?: object;\r\n  state?: string;\r\n}\r\n\r\n/**\r\n * Represents the parsed and validated id_token.\r\n */\r\nexport interface ParsedIdToken {\r\n  idToken: string;\r\n  idTokenClaims: object;\r\n  idTokenHeader: object;\r\n  idTokenClaimsJson: string;\r\n  idTokenHeaderJson: string;\r\n  idTokenExpiresAt: number;\r\n}\r\n\r\n/**\r\n * Represents the response from the token endpoint\r\n * http://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint\r\n */\r\nexport interface TokenResponse {\r\n  access_token: string;\r\n  token_type: string;\r\n  expires_in: number;\r\n  refresh_token: string;\r\n  scope: string;\r\n  state?: string;\r\n}\r\n\r\n/**\r\n * Represents the response from the user info endpoint\r\n * http://openid.net/specs/openid-connect-core-1_0.html#UserInfo\r\n */\r\nexport interface UserInfo {\r\n  sub: string;\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Represents an OpenID Connect discovery document\r\n */\r\nexport interface OidcDiscoveryDoc {\r\n  issuer: string;\r\n  authorization_endpoint: string;\r\n  token_endpoint: string;\r\n  token_endpoint_auth_methods_supported: string[];\r\n  token_endpoint_auth_signing_alg_values_supported: string[];\r\n  userinfo_endpoint: string;\r\n  check_session_iframe: string;\r\n  end_session_endpoint: string;\r\n  jwks_uri: string;\r\n  registration_endpoint: string;\r\n  scopes_supported: string[];\r\n  response_types_supported: string[];\r\n  acr_values_supported: string[];\r\n  response_modes_supported: string[];\r\n  grant_types_supported: string[];\r\n  subject_types_supported: string[];\r\n  userinfo_signing_alg_values_supported: string[];\r\n  userinfo_encryption_alg_values_supported: string[];\r\n  userinfo_encryption_enc_values_supported: string[];\r\n  id_token_signing_alg_values_supported: string[];\r\n  id_token_encryption_alg_values_supported: string[];\r\n  id_token_encryption_enc_values_supported: string[];\r\n  request_object_signing_alg_values_supported: string[];\r\n  display_values_supported: string[];\r\n  claim_types_supported: string[];\r\n  claims_supported: string[];\r\n  claims_parameter_supported: boolean;\r\n  service_documentation: string;\r\n  ui_locales_supported: string[];\r\n}\r\n",
    "export interface ValidationParams {\r\n  idToken: string;\r\n  accessToken: string;\r\n  idTokenHeader: object;\r\n  idTokenClaims: object;\r\n  jwks: object;\r\n  loadKeys: () => Promise<object>;\r\n}\r\n\r\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\r\nexport abstract class ValidationHandler {\r\n  /**\r\n   * Validates the signature of an id_token.\r\n   */\r\n  public abstract validateSignature(\r\n    validationParams: ValidationParams\r\n  ): Promise<any>;\r\n\r\n  /**\r\n   * Validates the at_hash in an id_token against the received access_token.\r\n   */\r\n  public abstract validateAtHash(validationParams: ValidationParams): boolean;\r\n}\r\n\r\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\r\nexport abstract class AbstractValidationHandler implements ValidationHandler {\r\n  /**\r\n   * Validates the signature of an id_token.\r\n   */\r\n  abstract validateSignature(validationParams: ValidationParams): Promise<any>;\r\n\r\n  /**\r\n   * Validates the at_hash in an id_token against the received access_token.\r\n   */\r\n  validateAtHash(params: ValidationParams): boolean {\r\n    let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\r\n\r\n    let tokenHash = this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\r\n\r\n    let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\r\n\r\n    let tokenHashBase64 = btoa(leftMostHalf);\r\n\r\n    let atHash = tokenHashBase64\r\n      .replace(/\\+/g, '-')\r\n      .replace(/\\//g, '_')\r\n      .replace(/=/g, '');\r\n    let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\r\n\r\n    if (atHash !== claimsAtHash) {\r\n      console.error('exptected at_hash: ' + atHash);\r\n      console.error('actual at_hash: ' + claimsAtHash);\r\n    }\r\n\r\n    return atHash === claimsAtHash;\r\n  }\r\n\r\n  /**\r\n   * Infers the name of the hash algorithm to use\r\n   * from the alg field of an id_token.\r\n   *\r\n   * @param jwtHeader the id_token's parsed header\r\n   */\r\n  protected inferHashAlgorithm(jwtHeader: object): string {\r\n    let alg: string = jwtHeader['alg'];\r\n\r\n    if (!alg.match(/^.S[0-9]{3}$/)) {\r\n      throw new Error('Algorithm not supported: ' + alg);\r\n    }\r\n\r\n    return 'sha' + alg.substr(2);\r\n  }\r\n\r\n  /**\r\n   * Calculates the hash for the passed value by using\r\n   * the passed hash algorithm.\r\n   *\r\n   * @param valueToHash\r\n   * @param algorithm\r\n   */\r\n  protected abstract calcHash(valueToHash: string, algorithm: string): string;\r\n}\r\n",
    "import { Injectable } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class UrlHelperService {\r\n  public getHashFragmentParams(customHashFragment?: string): object {\r\n    let hash = customHashFragment || window.location.hash;\r\n\r\n    hash = decodeURIComponent(hash);\r\n\r\n    if (hash.indexOf('#') !== 0) {\r\n      return {};\r\n    }\r\n\r\n    const questionMarkPosition = hash.indexOf('?');\r\n\r\n    if (questionMarkPosition > -1) {\r\n      hash = hash.substr(questionMarkPosition + 1);\r\n    } else {\r\n      hash = hash.substr(1);\r\n    }\r\n\r\n    return this.parseQueryString(hash);\r\n  }\r\n\r\n  public parseQueryString(queryString: string): object {\r\n    const data = {};\r\n    let\r\n      pairs,\r\n      pair,\r\n      separatorIndex,\r\n      escapedKey,\r\n      escapedValue,\r\n      key,\r\n      value;\r\n\r\n    if (queryString === null) {\r\n      return data;\r\n    }\r\n\r\n    pairs = queryString.split('&');\r\n\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      pair = pairs[i];\r\n      separatorIndex = pair.indexOf('=');\r\n\r\n      if (separatorIndex === -1) {\r\n        escapedKey = pair;\r\n        escapedValue = null;\r\n      } else {\r\n        escapedKey = pair.substr(0, separatorIndex);\r\n        escapedValue = pair.substr(separatorIndex + 1);\r\n      }\r\n\r\n      key = decodeURIComponent(escapedKey);\r\n      value = decodeURIComponent(escapedValue);\r\n\r\n      if (key.substr(0, 1) === '/') { key = key.substr(1); }\r\n\r\n      data[key] = value;\r\n    }\r\n\r\n    return data;\r\n  }\r\n}\r\n",
    "export type EventType =\r\n  | 'discovery_document_loaded'\r\n  | 'received_first_token'\r\n  | 'jwks_load_error'\r\n  | 'invalid_nonce_in_state'\r\n  | 'discovery_document_load_error'\r\n  | 'discovery_document_validation_error'\r\n  | 'user_profile_loaded'\r\n  | 'user_profile_load_error'\r\n  | 'token_received'\r\n  | 'token_error'\r\n  | 'token_refreshed'\r\n  | 'token_refresh_error'\r\n  | 'silent_refresh_error'\r\n  | 'silently_refreshed'\r\n  | 'silent_refresh_timeout'\r\n  | 'token_validation_error'\r\n  | 'token_expires'\r\n  | 'session_changed'\r\n  | 'session_error'\r\n  | 'session_terminated'\r\n  | 'logout';\r\n\r\nexport abstract class OAuthEvent {\r\n  constructor(readonly type: EventType) {}\r\n}\r\n\r\nexport class OAuthSuccessEvent extends OAuthEvent {\r\n  constructor(type: EventType, readonly info: any = null) {\r\n    super(type);\r\n  }\r\n}\r\n\r\nexport class OAuthInfoEvent extends OAuthEvent {\r\n  constructor(type: EventType, readonly info: any = null) {\r\n    super(type);\r\n  }\r\n}\r\n\r\nexport class OAuthErrorEvent extends OAuthEvent {\r\n  constructor(\r\n    type: EventType,\r\n    readonly reason: object,\r\n    readonly params: object = null\r\n  ) {\r\n    super(type);\r\n  }\r\n}\r\n",
    "// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\r\nexport function b64DecodeUnicode(str) {\r\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\r\n\r\n  return decodeURIComponent(\r\n    atob(base64)\r\n      .split('')\r\n      .map(function(c) {\r\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n      })\r\n      .join('')\r\n  );\r\n}\r\n",
    "export class AuthConfig {\r\n  /**\r\n   * The client's id as registered with the auth server\r\n   */\r\n  public clientId? = '';\r\n\r\n  /**\r\n   * The client's redirectUri as registered with the auth server\r\n   */\r\n  public redirectUri? = '';\r\n\r\n  /**\r\n   * An optional second redirectUri where the auth server\r\n   * redirects the user to after logging out.\r\n   */\r\n  public postLogoutRedirectUri? = '';\r\n\r\n  /**\r\n   * The auth server's endpoint that allows to log\r\n   * the user in when using implicit flow.\r\n   */\r\n  public loginUrl? = '';\r\n\r\n  /**\r\n   * The requested scopes\r\n   */\r\n  public scope? = 'openid profile';\r\n\r\n  public resource? = '';\r\n\r\n  public rngUrl? = '';\r\n\r\n  /**\r\n   * Defines whether to use OpenId Connect during\r\n   * implicit flow.\r\n   */\r\n  public oidc? = true;\r\n\r\n  /**\r\n   * Defines whether to request a access token during\r\n   * implicit flow.\r\n   */\r\n  public requestAccessToken? = true;\r\n\r\n  public options?: any = null;\r\n\r\n  /**\r\n   * The issuer's uri.\r\n   */\r\n  public issuer? = '';\r\n\r\n  /**\r\n   * The logout url.\r\n   */\r\n  public logoutUrl? = '';\r\n\r\n  /**\r\n   * Defines whether to clear the hash fragment after logging in.\r\n   */\r\n  public clearHashAfterLogin? = true;\r\n\r\n  /**\r\n   * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n   */\r\n  public tokenEndpoint?: string = null;\r\n\r\n  /**\r\n   * Url of the userinfo endpoint as defined by OpenId Connect.\r\n   *\r\n   */\r\n  public userinfoEndpoint?: string = null;\r\n\r\n  public responseType? = 'token';\r\n\r\n  /**\r\n   * Defines whether additional debug information should\r\n   * be shown at the console.\r\n   */\r\n  public showDebugInformation? = false;\r\n\r\n  /**\r\n   * The redirect uri used when doing silent refresh.\r\n   */\r\n  public silentRefreshRedirectUri? = '';\r\n\r\n  public silentRefreshMessagePrefix? = '';\r\n\r\n  /**\r\n   * Set this to true to display the iframe used for\r\n   * silent refresh for debugging.\r\n   */\r\n  public silentRefreshShowIFrame? = false;\r\n\r\n  /**\r\n   * Timeout for silent refresh.\r\n   * @internal\r\n   * depreacted b/c of typo, see silentRefreshTimeout\r\n   */\r\n  public siletRefreshTimeout?: number = 1000 * 20;\r\n\r\n  /**\r\n   * Timeout for silent refresh.\r\n   */\r\n  public silentRefreshTimeout?: number = 1000 * 20;\r\n\r\n  /**\r\n   * Some auth servers don't allow using password flow\r\n   * w/o a client secreat while the standards do not\r\n   * demand for it. In this case, you can set a password\r\n   * here. As this passwort is exposed to the public\r\n   * it does not bring additional security and is therefore\r\n   * as good as using no password.\r\n   */\r\n  public dummyClientSecret?: string = null;\r\n\r\n  /**\r\n   * Defines whether https is required.\r\n   * The default value is remoteOnly which only allows\r\n   * http for localhost, while every other domains need\r\n   * to be used with https.\r\n   */\r\n  public requireHttps?: boolean | 'remoteOnly' = 'remoteOnly';\r\n\r\n  /**\r\n   * Defines whether every url provided by the discovery\r\n   * document has to start with the issuer's url.\r\n   */\r\n  public strictDiscoveryDocumentValidation? = true;\r\n\r\n  /**\r\n   * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n   * with keys used to validate received id_tokens.\r\n   * This is taken out of the disovery document. Can be set manually too.\r\n   */\r\n  public jwks?: object = null;\r\n\r\n  /**\r\n   * Map with additional query parameter that are appended to\r\n   * the request when initializing implicit flow.\r\n   */\r\n  public customQueryParams?: object = null;\r\n\r\n  public silentRefreshIFrameName? = 'angular-oauth-oidc-silent-refresh-iframe';\r\n\r\n  /**\r\n   * Defines when the token_timeout event should be raised.\r\n   * If you set this to the default value 0.75, the event\r\n   * is triggered after 75% of the token's life time.\r\n   */\r\n  public timeoutFactor? = 0.75;\r\n\r\n  /**\r\n   * If true, the lib will try to check whether the user\r\n   * is still logged in on a regular basis as described\r\n   * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n   */\r\n  public sessionChecksEnabled? = false;\r\n\r\n  /**\r\n   * Intervall in msec for checking the session\r\n   * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n   */\r\n  public sessionCheckIntervall? = 3 * 1000;\r\n\r\n  /**\r\n   * Url for the iframe used for session checks\r\n   */\r\n  public sessionCheckIFrameUrl?: string = null;\r\n\r\n  /**\r\n   * Name of the iframe to use for session checks\r\n   */\r\n  public sessionCheckIFrameName? = 'angular-oauth-oidc-check-session-iframe';\r\n\r\n  /**\r\n   * This property has been introduced to disable at_hash checks\r\n   * and is indented for Identity Provider that does not deliver\r\n   * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n   * Of course, when disabling these checks the we are bypassing\r\n   * a security check which means we are more vulnerable.\r\n   */\r\n  public disableAtHashCheck? = false;\r\n\r\n  /*\r\n     * Defines wether to check the subject of a refreshed token after silent refresh.\r\n     * Normally, it should be the same as before.\r\n    */\r\n  public skipSubjectCheck? = false;\r\n\r\n  public useIdTokenHintForSilentRefresh? = false;\r\n\r\n  /*\r\n     * Defined whether to skip the validation of the issuer in the discovery document.\r\n     * Normally, the discovey document's url starts with the url of the issuer.\r\n     */\r\n  public skipIssuerCheck? = false;\r\n\r\n  /**\r\n   * According to rfc6749 it is recommended (but not required) that the auth\r\n   * server exposes the access_token's life time in seconds.\r\n   * This is a fallback value for the case this value is not exposed.\r\n   */\r\n  public fallbackAccessTokenExpirationTimeInSec?: number;\r\n\r\n  /*\r\n     * final state sent to issuer is built as follows:\r\n     * state = nonce + nonceStateSeparator + additional state\r\n     * Default separator is ';' (encoded %3B).\r\n     * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n     */\r\n  public nonceStateSeparator? = ';';\r\n\r\n  /*\r\n   * set this to true to use HTTP BASIC auth for password flow\r\n  */\r\n  public useHttpBasicAuthForPasswordFlow? = false;\r\n\r\n  constructor(json?: Partial<AuthConfig>) {\r\n    if (json) {\r\n      Object.assign(this, json);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This property allows you to override the method that is used to open the login url,\r\n   * allowing a way for implementations to specify their own method of routing to new\r\n   * urls.\r\n   */\r\n  public openUri?: ((uri: string) => void) = uri => {\r\n    location.href = uri;\r\n  }\r\n}\r\n",
    "import { HttpParameterCodec } from '@angular/common/http';\r\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\r\nexport class WebHttpUrlEncodingCodec implements HttpParameterCodec {\r\n  encodeKey(k: string): string {\r\n    return encodeURIComponent(k);\r\n  }\r\n\r\n  encodeValue(v: string): string {\r\n    return encodeURIComponent(v);\r\n  }\r\n\r\n  decodeKey(k: string): string {\r\n    return decodeURIComponent(k);\r\n  }\r\n\r\n  decodeValue(v: string) {\r\n    return decodeURIComponent(v);\r\n  }\r\n}\r\n",
    "import { Injectable, NgZone, Optional } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\r\nimport { Observable, Subject, Subscription, of, race } from 'rxjs';\r\nimport { filter, take, delay, first, tap, map } from 'rxjs/operators';\r\n\r\nimport {\r\n  ValidationHandler,\r\n  ValidationParams\r\n} from './token-validation/validation-handler';\r\nimport { UrlHelperService } from './url-helper.service';\r\nimport {\r\n  OAuthEvent,\r\n  OAuthInfoEvent,\r\n  OAuthErrorEvent,\r\n  OAuthSuccessEvent\r\n} from './events';\r\nimport {\r\n  OAuthStorage,\r\n  LoginOptions,\r\n  ParsedIdToken,\r\n  OidcDiscoveryDoc,\r\n  TokenResponse,\r\n  UserInfo\r\n} from './types';\r\nimport { b64DecodeUnicode } from './base64-helper';\r\nimport { AuthConfig } from './auth.config';\r\nimport { WebHttpUrlEncodingCodec } from './encoder';\r\n\r\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\r\n@Injectable()\r\nexport class OAuthService extends AuthConfig {\r\n  // extending AuthConfig ist just for LEGACY reasons\r\n  // to not break existing code\r\n\r\n  /**\r\n   * The ValidationHandler used to validate received\r\n   * id_tokens.\r\n   */\r\n  public tokenValidationHandler: ValidationHandler;\r\n\r\n  /**\r\n   * @internal\r\n   * Deprecated:  use property events instead\r\n   */\r\n  public discoveryDocumentLoaded = false;\r\n\r\n  /**\r\n   * @internal\r\n   * Deprecated:  use property events instead\r\n   */\r\n  public discoveryDocumentLoaded$: Observable<object>;\r\n\r\n  /**\r\n   * Informs about events, like token_received or token_expires.\r\n   * See the string enum EventType for a full list of events.\r\n   */\r\n  public events: Observable<OAuthEvent>;\r\n\r\n  /**\r\n   * The received (passed around) state, when logging\r\n   * in with implicit flow.\r\n   */\r\n  public state? = '';\r\n\r\n  private eventsSubject: Subject<OAuthEvent> = new Subject<OAuthEvent>();\r\n  private discoveryDocumentLoadedSubject: Subject<object> = new Subject<\r\n    object\r\n  >();\r\n  private silentRefreshPostMessageEventListener: EventListener;\r\n  private grantTypesSupported: Array<string> = [];\r\n  private _storage: OAuthStorage;\r\n  private accessTokenTimeoutSubscription: Subscription;\r\n  private idTokenTimeoutSubscription: Subscription;\r\n  private sessionCheckEventListener: EventListener;\r\n  private jwksUri: string;\r\n  private sessionCheckTimer: any;\r\n  private silentRefreshSubject: string;\r\n  private inImplicitFlow = false;\r\n\r\n  constructor(\r\n    private ngZone: NgZone,\r\n    private http: HttpClient,\r\n    @Optional() storage: OAuthStorage,\r\n    @Optional() tokenValidationHandler: ValidationHandler,\r\n    @Optional() private config: AuthConfig,\r\n    private urlHelper: UrlHelperService\r\n  ) {\r\n    super();\r\n\r\n    this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\r\n    this.events = this.eventsSubject.asObservable();\r\n\r\n    if (tokenValidationHandler) {\r\n      this.tokenValidationHandler = tokenValidationHandler;\r\n    }\r\n\r\n    if (config) {\r\n      this.configure(config);\r\n    }\r\n\r\n    try {\r\n      if (storage) {\r\n        this.setStorage(storage);\r\n      } else if (typeof sessionStorage !== 'undefined') {\r\n        this.setStorage(sessionStorage);\r\n      }\r\n    } catch (e) {\r\n      console.error(\r\n        'cannot access sessionStorage. Consider setting an own storage implementation using setStorage',\r\n        e\r\n      );\r\n    }\r\n    this.setupRefreshTimer();\r\n  }\r\n\r\n  /**\r\n   * Use this method to configure the service\r\n   * @param config the configuration\r\n   */\r\n  public configure(config: AuthConfig) {\r\n    // For the sake of downward compatibility with\r\n    // original configuration API\r\n    Object.assign(this, new AuthConfig(), config);\r\n\r\n    this.config = Object.assign({} as AuthConfig, new AuthConfig(), config);\r\n\r\n    if (this.sessionChecksEnabled) {\r\n      this.setupSessionCheck();\r\n    }\r\n\r\n    this.configChanged();\r\n  }\r\n\r\n  private configChanged(): void {}\r\n\r\n  public restartSessionChecksIfStillLoggedIn(): void {\r\n    if (this.hasValidIdToken()) {\r\n      this.initSessionCheck();\r\n    }\r\n  }\r\n\r\n  private restartRefreshTimerIfStillLoggedIn(): void {\r\n    this.setupExpirationTimers();\r\n  }\r\n\r\n  private setupSessionCheck() {\r\n    this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\r\n      this.initSessionCheck();\r\n    });\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param params Additional parameter to pass\r\n   */\r\n  public setupAutomaticSilentRefresh(params: object = {}) {\r\n    this.events.pipe(filter(e => e.type === 'token_expires')).subscribe(e => {\r\n      this.silentRefresh(params).catch(_ => {\r\n        this.debug('automatic silent refresh did not work');\r\n      });\r\n    });\r\n\r\n    this.restartRefreshTimerIfStillLoggedIn();\r\n  }\r\n\r\n  public loadDiscoveryDocumentAndTryLogin(options: LoginOptions = null) {\r\n    return this.loadDiscoveryDocument().then(doc => {\r\n      return this.tryLogin(options);\r\n    });\r\n  }\r\n\r\n  public loadDiscoveryDocumentAndLogin(options: LoginOptions = null) {\r\n    return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\r\n      if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\r\n        this.initImplicitFlow();\r\n        return false;\r\n      } else {\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n\r\n  private debug(...args): void {\r\n    if (this.showDebugInformation) {\r\n      console.debug.apply(console, args);\r\n    }\r\n  }\r\n\r\n  private validateUrlFromDiscoveryDocument(url: string): string[] {\r\n    const errors: string[] = [];\r\n    const httpsCheck = this.validateUrlForHttps(url);\r\n    const issuerCheck = this.validateUrlAgainstIssuer(url);\r\n\r\n    if (!httpsCheck) {\r\n      errors.push(\r\n        'https for all urls required. Also for urls received by discovery.'\r\n      );\r\n    }\r\n\r\n    if (!issuerCheck) {\r\n      errors.push(\r\n        'Every url in discovery document has to start with the issuer url.' +\r\n          'Also see property strictDiscoveryDocumentValidation.'\r\n      );\r\n    }\r\n\r\n    return errors;\r\n  }\r\n\r\n  private validateUrlForHttps(url: string): boolean {\r\n    if (!url) {\r\n      return true;\r\n    }\r\n\r\n    const lcUrl = url.toLowerCase();\r\n\r\n    if (this.requireHttps === false) {\r\n      return true;\r\n    }\r\n\r\n    if (\r\n      (lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\r\n        lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\r\n      this.requireHttps === 'remoteOnly'\r\n    ) {\r\n      return true;\r\n    }\r\n\r\n    return lcUrl.startsWith('https://');\r\n  }\r\n\r\n  private validateUrlAgainstIssuer(url: string) {\r\n    if (!this.strictDiscoveryDocumentValidation) {\r\n      return true;\r\n    }\r\n    if (!url) {\r\n      return true;\r\n    }\r\n    return url.toLowerCase().startsWith(this.issuer.toLowerCase());\r\n  }\r\n\r\n  private setupRefreshTimer(): void {\r\n    if (typeof window === 'undefined') {\r\n      this.debug('timer not supported on this plattform');\r\n      return;\r\n    }\r\n\r\n    if (this.hasValidIdToken) {\r\n      this.clearAccessTokenTimer();\r\n      this.clearIdTokenTimer();\r\n      this.setupExpirationTimers();\r\n    }\r\n\r\n    this.events.pipe(filter(e => e.type === 'token_received')).subscribe(_ => {\r\n      this.clearAccessTokenTimer();\r\n      this.clearIdTokenTimer();\r\n      this.setupExpirationTimers();\r\n    });\r\n  }\r\n\r\n  private setupExpirationTimers(): void {\r\n    const idTokenExp = this.getIdTokenExpiration() || Number.MAX_VALUE;\r\n    const accessTokenExp = this.getAccessTokenExpiration() || Number.MAX_VALUE;\r\n    const useAccessTokenExp = accessTokenExp <= idTokenExp;\r\n\r\n    if (this.hasValidAccessToken() && useAccessTokenExp) {\r\n      this.setupAccessTokenTimer();\r\n    }\r\n\r\n    if (this.hasValidIdToken() && !useAccessTokenExp) {\r\n      this.setupIdTokenTimer();\r\n    }\r\n  }\r\n\r\n  private setupAccessTokenTimer(): void {\r\n    const expiration = this.getAccessTokenExpiration();\r\n    const storedAt = this.getAccessTokenStoredAt();\r\n    const timeout = this.calcTimeout(storedAt, expiration);\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this.accessTokenTimeoutSubscription = of(\r\n        new OAuthInfoEvent('token_expires', 'access_token')\r\n      )\r\n        .pipe(delay(timeout))\r\n        .subscribe(e => {\r\n          this.ngZone.run(() => {\r\n            this.eventsSubject.next(e);\r\n          });\r\n        });\r\n    });\r\n  }\r\n\r\n  private setupIdTokenTimer(): void {\r\n    const expiration = this.getIdTokenExpiration();\r\n    const storedAt = this.getIdTokenStoredAt();\r\n    const timeout = this.calcTimeout(storedAt, expiration);\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this.idTokenTimeoutSubscription = of(\r\n        new OAuthInfoEvent('token_expires', 'id_token')\r\n      )\r\n        .pipe(delay(timeout))\r\n        .subscribe(e => {\r\n          this.ngZone.run(() => {\r\n            this.eventsSubject.next(e);\r\n          });\r\n        });\r\n    });\r\n  }\r\n\r\n  private clearAccessTokenTimer(): void {\r\n    if (this.accessTokenTimeoutSubscription) {\r\n      this.accessTokenTimeoutSubscription.unsubscribe();\r\n    }\r\n  }\r\n\r\n  private clearIdTokenTimer(): void {\r\n    if (this.idTokenTimeoutSubscription) {\r\n      this.idTokenTimeoutSubscription.unsubscribe();\r\n    }\r\n  }\r\n\r\n  private calcTimeout(storedAt: number, expiration: number): number {\r\n    const delta = (expiration - storedAt) * this.timeoutFactor;\r\n    return delta;\r\n  }\r\n\r\n  /**\r\n   * Sets a custom storage used to store the received\r\n   * tokens on client side. By default, the browser's\r\n   * sessionStorage is used.\r\n   *\r\n   * @param storage\r\n   */\r\n  public setStorage(storage: OAuthStorage): void {\r\n    this._storage = storage;\r\n    this.configChanged();\r\n  }\r\n\r\n  /**\r\n   * Loads the discovery document to configure most\r\n   * properties of this service. The url of the discovery\r\n   * document is infered from the issuer's url according\r\n   * to the OpenId Connect spec. To use another url you\r\n   * can pass it to to optional parameter fullUrl.\r\n   *\r\n   * @param fullUrl\r\n   */\r\n  public loadDiscoveryDocument(fullUrl: string = null): Promise<object> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!fullUrl) {\r\n        fullUrl = this.issuer || '';\r\n        if (!fullUrl.endsWith('/')) {\r\n          fullUrl += '/';\r\n        }\r\n        fullUrl += '.well-known/openid-configuration';\r\n      }\r\n\r\n      if (!this.validateUrlForHttps(fullUrl)) {\r\n        reject('issuer must use Https. Also check property requireHttps.');\r\n        return;\r\n      }\r\n\r\n      this.http.get<OidcDiscoveryDoc>(fullUrl).subscribe(\r\n        doc => {\r\n          if (!this.validateDiscoveryDocument(doc)) {\r\n            this.eventsSubject.next(\r\n              new OAuthErrorEvent('discovery_document_validation_error', null)\r\n            );\r\n            reject('discovery_document_validation_error');\r\n            return;\r\n          }\r\n\r\n          this.loginUrl = doc.authorization_endpoint;\r\n          this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\r\n          this.grantTypesSupported = doc.grant_types_supported;\r\n          this.issuer = doc.issuer;\r\n          this.tokenEndpoint = doc.token_endpoint;\r\n          this.userinfoEndpoint = doc.userinfo_endpoint;\r\n          this.jwksUri = doc.jwks_uri;\r\n          this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\r\n\r\n          this.discoveryDocumentLoaded = true;\r\n          this.discoveryDocumentLoadedSubject.next(doc);\r\n\r\n          if (this.sessionChecksEnabled) {\r\n            this.restartSessionChecksIfStillLoggedIn();\r\n          }\r\n\r\n          this.loadJwks()\r\n            .then(jwks => {\r\n              const result: object = {\r\n                discoveryDocument: doc,\r\n                jwks: jwks\r\n              };\r\n\r\n              const event = new OAuthSuccessEvent(\r\n                'discovery_document_loaded',\r\n                result\r\n              );\r\n              this.eventsSubject.next(event);\r\n              resolve(event);\r\n              return;\r\n            })\r\n            .catch(err => {\r\n              this.eventsSubject.next(\r\n                new OAuthErrorEvent('discovery_document_load_error', err)\r\n              );\r\n              reject(err);\r\n              return;\r\n            });\r\n        },\r\n        err => {\r\n          console.error('error loading discovery document', err);\r\n          this.eventsSubject.next(\r\n            new OAuthErrorEvent('discovery_document_load_error', err)\r\n          );\r\n          reject(err);\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  private loadJwks(): Promise<object> {\r\n    return new Promise<object>((resolve, reject) => {\r\n      if (this.jwksUri) {\r\n        this.http.get(this.jwksUri).subscribe(\r\n          jwks => {\r\n            this.jwks = jwks;\r\n            this.eventsSubject.next(\r\n              new OAuthSuccessEvent('discovery_document_loaded')\r\n            );\r\n            resolve(jwks);\r\n          },\r\n          err => {\r\n            console.error('error loading jwks', err);\r\n            this.eventsSubject.next(\r\n              new OAuthErrorEvent('jwks_load_error', err)\r\n            );\r\n            reject(err);\r\n          }\r\n        );\r\n      } else {\r\n        resolve(null);\r\n      }\r\n    });\r\n  }\r\n\r\n  private validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean {\r\n    let errors: string[];\r\n\r\n    if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\r\n      console.error(\r\n        'invalid issuer in discovery document',\r\n        'expected: ' + this.issuer,\r\n        'current: ' + doc.issuer\r\n      );\r\n      return false;\r\n    }\r\n\r\n    errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\r\n    if (errors.length > 0) {\r\n      console.error(\r\n        'error validating authorization_endpoint in discovery document',\r\n        errors\r\n      );\r\n      return false;\r\n    }\r\n\r\n    errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\r\n    if (errors.length > 0) {\r\n      console.error(\r\n        'error validating end_session_endpoint in discovery document',\r\n        errors\r\n      );\r\n      return false;\r\n    }\r\n\r\n    errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\r\n    if (errors.length > 0) {\r\n      console.error(\r\n        'error validating token_endpoint in discovery document',\r\n        errors\r\n      );\r\n    }\r\n\r\n    errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\r\n    if (errors.length > 0) {\r\n      console.error(\r\n        'error validating userinfo_endpoint in discovery document',\r\n        errors\r\n      );\r\n      return false;\r\n    }\r\n\r\n    errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\r\n    if (errors.length > 0) {\r\n      console.error('error validating jwks_uri in discovery document', errors);\r\n      return false;\r\n    }\r\n\r\n    if (this.sessionChecksEnabled && !doc.check_session_iframe) {\r\n      console.warn(\r\n        'sessionChecksEnabled is activated but discovery document' +\r\n          ' does not contain a check_session_iframe field'\r\n      );\r\n    }\r\n\r\n    // this.sessionChecksEnabled = !!doc.check_session_iframe;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Uses password flow to exchange userName and password for an\r\n   * access_token. After receiving the access_token, this method\r\n   * uses it to query the userinfo endpoint in order to get information\r\n   * about the user in question.\r\n   *\r\n   * When using this, make sure that the property oidc is set to false.\r\n   * Otherwise stricter validations take happen that makes this operation\r\n   * fail.\r\n   *\r\n   * @param userName\r\n   * @param password\r\n   * @param headers Optional additional http-headers.\r\n   */\r\n  public fetchTokenUsingPasswordFlowAndLoadUserProfile(\r\n    userName: string,\r\n    password: string,\r\n    headers: HttpHeaders = new HttpHeaders()\r\n  ): Promise<object> {\r\n    return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(\r\n      () => this.loadUserProfile()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n   *\r\n   * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n   * Otherwise stricter validations take happen that makes this operation\r\n   * fail.\r\n   */\r\n  public loadUserProfile(): Promise<object> {\r\n    if (!this.hasValidAccessToken()) {\r\n      throw new Error('Can not load User Profile without access_token');\r\n    }\r\n    if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\r\n      throw new Error(\r\n        'userinfoEndpoint must use Http. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const headers = new HttpHeaders().set(\r\n        'Authorization',\r\n        'Bearer ' + this.getAccessToken()\r\n      );\r\n\r\n      this.http.get<UserInfo>(this.userinfoEndpoint, { headers }).subscribe(\r\n        info => {\r\n          this.debug('userinfo received', info);\r\n\r\n          const existingClaims = this.getIdentityClaims() || {};\r\n\r\n          if (!this.skipSubjectCheck) {\r\n            if (\r\n              this.oidc &&\r\n              (!existingClaims['sub'] || info.sub !== existingClaims['sub'])\r\n            ) {\r\n              const err =\r\n                'if property oidc is true, the received user-id (sub) has to be the user-id ' +\r\n                'of the user that has logged in with oidc.\\n' +\r\n                'if you are not using oidc but just oauth2 password flow set oidc to false';\r\n\r\n              reject(err);\r\n              return;\r\n            }\r\n          }\r\n\r\n          info = Object.assign({}, existingClaims, info);\r\n\r\n          this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\r\n          this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\r\n          resolve(info);\r\n        },\r\n        err => {\r\n          console.error('error loading user info', err);\r\n          this.eventsSubject.next(\r\n            new OAuthErrorEvent('user_profile_load_error', err)\r\n          );\r\n          reject(err);\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Uses password flow to exchange userName and password for an access_token.\r\n   * @param userName\r\n   * @param password\r\n   * @param headers Optional additional http-headers.\r\n   */\r\n  public fetchTokenUsingPasswordFlow(\r\n    userName: string,\r\n    password: string,\r\n    headers: HttpHeaders = new HttpHeaders()\r\n  ): Promise<object> {\r\n    if (!this.validateUrlForHttps(this.tokenEndpoint)) {\r\n      throw new Error(\r\n        'tokenEndpoint must use Http. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      /**\r\n       * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n       * serialize and parse URL parameter keys and values.\r\n       *\r\n       * @stable\r\n       */\r\n      let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\r\n        .set('grant_type', 'password')\r\n        .set('scope', this.scope)\r\n        .set('username', userName)\r\n        .set('password', password);\r\n\r\n      if (this.useHttpBasicAuthForPasswordFlow) {\r\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\r\n        headers = headers.set(\r\n                    'Authentication',\r\n                    'BASIC ' + header);\r\n      }\r\n\r\n      if (!this.useHttpBasicAuthForPasswordFlow) {\r\n        params = params.set('client_id', this.clientId);\r\n      }\r\n\r\n      if (!this.useHttpBasicAuthForPasswordFlow && this.dummyClientSecret) {\r\n        params = params.set('client_secret', this.dummyClientSecret);\r\n      }\r\n\r\n      if (this.customQueryParams) {\r\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n          params = params.set(key, this.customQueryParams[key]);\r\n        }\r\n      }\r\n\r\n      headers = headers.set(\r\n        'Content-Type',\r\n        'application/x-www-form-urlencoded'\r\n      );\r\n\r\n      this.http\r\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\r\n        .subscribe(\r\n          tokenResponse => {\r\n            this.debug('tokenResponse', tokenResponse);\r\n            this.storeAccessTokenResponse(\r\n              tokenResponse.access_token,\r\n              tokenResponse.refresh_token,\r\n              tokenResponse.expires_in,\r\n              tokenResponse.scope\r\n            );\r\n\r\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n            resolve(tokenResponse);\r\n          },\r\n          err => {\r\n            console.error('Error performing password flow', err);\r\n            this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\r\n            reject(err);\r\n          }\r\n        );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refreshes the token using a refresh_token.\r\n   * This does not work for implicit flow, b/c\r\n   * there is no refresh_token in this flow.\r\n   * A solution for this is provided by the\r\n   * method silentRefresh.\r\n   */\r\n  public refreshToken(): Promise<object> {\r\n    if (!this.validateUrlForHttps(this.tokenEndpoint)) {\r\n      throw new Error(\r\n        'tokenEndpoint must use Http. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let params = new HttpParams()\r\n        .set('grant_type', 'refresh_token')\r\n        .set('client_id', this.clientId)\r\n        .set('scope', this.scope)\r\n        .set('refresh_token', this._storage.getItem('refresh_token'));\r\n\r\n      if (this.dummyClientSecret) {\r\n        params = params.set('client_secret', this.dummyClientSecret);\r\n      }\r\n\r\n      if (this.customQueryParams) {\r\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n          params = params.set(key, this.customQueryParams[key]);\r\n        }\r\n      }\r\n\r\n      const headers = new HttpHeaders().set(\r\n        'Content-Type',\r\n        'application/x-www-form-urlencoded'\r\n      );\r\n\r\n      this.http\r\n        .post<TokenResponse>(this.tokenEndpoint, params, { headers })\r\n        .subscribe(\r\n          tokenResponse => {\r\n            this.debug('refresh tokenResponse', tokenResponse);\r\n            this.storeAccessTokenResponse(\r\n              tokenResponse.access_token,\r\n              tokenResponse.refresh_token,\r\n              tokenResponse.expires_in,\r\n              tokenResponse.scope\r\n            );\r\n\r\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n            this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\r\n            resolve(tokenResponse);\r\n          },\r\n          err => {\r\n            console.error('Error performing password flow', err);\r\n            this.eventsSubject.next(\r\n              new OAuthErrorEvent('token_refresh_error', err)\r\n            );\r\n            reject(err);\r\n          }\r\n        );\r\n    });\r\n  }\r\n\r\n  private removeSilentRefreshEventListener(): void {\r\n    if (this.silentRefreshPostMessageEventListener) {\r\n      window.removeEventListener(\r\n        'message',\r\n        this.silentRefreshPostMessageEventListener\r\n      );\r\n      this.silentRefreshPostMessageEventListener = null;\r\n    }\r\n  }\r\n\r\n  private setupSilentRefreshEventListener(): void {\r\n    this.removeSilentRefreshEventListener();\r\n\r\n    this.silentRefreshPostMessageEventListener = (e: MessageEvent) => {\r\n      let expectedPrefix = '#';\r\n\r\n      if (this.silentRefreshMessagePrefix) {\r\n        expectedPrefix += this.silentRefreshMessagePrefix;\r\n      }\r\n\r\n      if (!e || !e.data || typeof e.data !== 'string') {\r\n        return;\r\n      }\r\n\r\n      const prefixedMessage: string = e.data;\r\n\r\n      if (!prefixedMessage.startsWith(expectedPrefix)) {\r\n        return;\r\n      }\r\n\r\n      const message = '#' + prefixedMessage.substr(expectedPrefix.length);\r\n\r\n      this.tryLogin({\r\n        customHashFragment: message,\r\n        preventClearHashAfterLogin: true,\r\n        onLoginError: err => {\r\n          this.eventsSubject.next(\r\n            new OAuthErrorEvent('silent_refresh_error', err)\r\n          );\r\n        },\r\n        onTokenReceived: () => {\r\n          this.eventsSubject.next(new OAuthSuccessEvent('silently_refreshed'));\r\n        }\r\n      }).catch(err => this.debug('tryLogin during silent refresh failed', err));\r\n    };\r\n\r\n    window.addEventListener(\r\n      'message',\r\n      this.silentRefreshPostMessageEventListener\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Performs a silent refresh for implicit flow.\r\n   * Use this method to get a new tokens when/ before\r\n   * the existing tokens expires.\r\n   */\r\n  public silentRefresh(params: object = {}, noPrompt = true): Promise<OAuthEvent> {\r\n    const claims: object = this.getIdentityClaims() || {};\r\n\r\n    if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken) {\r\n      params['id_token_hint'] = this.getIdToken();\r\n    }\r\n\r\n    /*\r\n        if (!claims) {\r\n            throw new Error('cannot perform a silent refresh as the user is not logged in');\r\n        }\r\n        */\r\n\r\n    if (!this.validateUrlForHttps(this.loginUrl)) {\r\n      throw new Error(\r\n        'tokenEndpoint must use Https. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    if (typeof document === 'undefined') {\r\n      throw new Error('silent refresh is not supported on this platform');\r\n    }\r\n\r\n    const existingIframe = document.getElementById(\r\n      this.silentRefreshIFrameName\r\n    );\r\n    if (existingIframe) {\r\n      document.body.removeChild(existingIframe);\r\n    }\r\n\r\n    this.silentRefreshSubject = claims['sub'];\r\n\r\n    const iframe = document.createElement('iframe');\r\n    iframe.id = this.silentRefreshIFrameName;\r\n\r\n    this.setupSilentRefreshEventListener();\r\n\r\n    const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\r\n    this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\r\n      iframe.setAttribute('src', url);\r\n      if (!this.silentRefreshShowIFrame) {\r\n        iframe.style['display'] = 'none';\r\n      }\r\n      document.body.appendChild(iframe);\r\n    });\r\n\r\n    const errors = this.events.pipe(\r\n      filter(e => e instanceof OAuthErrorEvent),\r\n      first()\r\n    );\r\n    const success = this.events.pipe(\r\n      filter(e => e.type === 'silently_refreshed'),\r\n      first()\r\n    );\r\n    const timeout = of(\r\n      new OAuthErrorEvent('silent_refresh_timeout', null)\r\n    ).pipe(delay(this.silentRefreshTimeout));\r\n\r\n    return race([errors, success, timeout])\r\n      .pipe(\r\n        tap(e => {\r\n          if (e.type === 'silent_refresh_timeout') {\r\n            this.eventsSubject.next(e);\r\n          }\r\n        }),\r\n        map(e => {\r\n          if (e instanceof OAuthErrorEvent) {\r\n            throw e;\r\n          }\r\n          return e;\r\n        })\r\n      )\r\n      .toPromise();\r\n  }\r\n\r\n  private canPerformSessionCheck(): boolean {\r\n    if (!this.sessionChecksEnabled) {\r\n      return false;\r\n    }\r\n    if (!this.sessionCheckIFrameUrl) {\r\n      console.warn(\r\n        'sessionChecksEnabled is activated but there ' +\r\n          'is no sessionCheckIFrameUrl'\r\n      );\r\n      return false;\r\n    }\r\n    const sessionState = this.getSessionState();\r\n    if (!sessionState) {\r\n      console.warn(\r\n        'sessionChecksEnabled is activated but there ' + 'is no session_state'\r\n      );\r\n      return false;\r\n    }\r\n    if (typeof document === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private setupSessionCheckEventListener(): void {\r\n    this.removeSessionCheckEventListener();\r\n\r\n    this.sessionCheckEventListener = (e: MessageEvent) => {\r\n      const origin = e.origin.toLowerCase();\r\n      const issuer = this.issuer.toLowerCase();\r\n\r\n      this.debug('sessionCheckEventListener');\r\n\r\n      if (!issuer.startsWith(origin)) {\r\n        this.debug(\r\n          'sessionCheckEventListener',\r\n          'wrong origin',\r\n          origin,\r\n          'expected',\r\n          issuer\r\n        );\r\n      }\r\n\r\n      switch (e.data) {\r\n        case 'unchanged':\r\n          this.handleSessionUnchanged();\r\n          break;\r\n        case 'changed':\r\n          this.handleSessionChange();\r\n          break;\r\n        case 'error':\r\n          this.handleSessionError();\r\n          break;\r\n      }\r\n\r\n      this.debug('got info from session check inframe', e);\r\n    };\r\n\r\n    window.addEventListener('message', this.sessionCheckEventListener);\r\n  }\r\n\r\n  private handleSessionUnchanged(): void {\r\n    this.debug('session check', 'session unchanged');\r\n  }\r\n\r\n  private handleSessionChange(): void {\r\n    /* events: session_changed, relogin, stopTimer, logged_out*/\r\n    this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\r\n    this.stopSessionCheckTimer();\r\n    if (this.silentRefreshRedirectUri) {\r\n      this.silentRefresh().catch(_ =>\r\n        this.debug('silent refresh failed after session changed')\r\n      );\r\n      this.waitForSilentRefreshAfterSessionChange();\r\n    } else {\r\n      this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\r\n      this.logOut(true);\r\n    }\r\n  }\r\n\r\n  private waitForSilentRefreshAfterSessionChange() {\r\n    this.events\r\n      .pipe(\r\n        filter(\r\n          (e: OAuthEvent) =>\r\n            e.type === 'silently_refreshed' ||\r\n            e.type === 'silent_refresh_timeout' ||\r\n            e.type === 'silent_refresh_error'\r\n        ),\r\n        first()\r\n      )\r\n      .subscribe(e => {\r\n        if (e.type !== 'silently_refreshed') {\r\n          this.debug('silent refresh did not work after session changed');\r\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\r\n          this.logOut(true);\r\n        }\r\n      });\r\n  }\r\n\r\n  private handleSessionError(): void {\r\n    this.stopSessionCheckTimer();\r\n    this.eventsSubject.next(new OAuthInfoEvent('session_error'));\r\n  }\r\n\r\n  private removeSessionCheckEventListener(): void {\r\n    if (this.sessionCheckEventListener) {\r\n      window.removeEventListener('message', this.sessionCheckEventListener);\r\n      this.sessionCheckEventListener = null;\r\n    }\r\n  }\r\n\r\n  private initSessionCheck(): void {\r\n    if (!this.canPerformSessionCheck()) {\r\n      return;\r\n    }\r\n\r\n    const existingIframe = document.getElementById(this.sessionCheckIFrameName);\r\n    if (existingIframe) {\r\n      document.body.removeChild(existingIframe);\r\n    }\r\n\r\n    const iframe = document.createElement('iframe');\r\n    iframe.id = this.sessionCheckIFrameName;\r\n\r\n    this.setupSessionCheckEventListener();\r\n\r\n    const url = this.sessionCheckIFrameUrl;\r\n    iframe.setAttribute('src', url);\r\n    // iframe.style.visibility = 'hidden';\r\n    iframe.style.display = 'none';\r\n    document.body.appendChild(iframe);\r\n\r\n    this.startSessionCheckTimer();\r\n  }\r\n\r\n  private startSessionCheckTimer(): void {\r\n    this.stopSessionCheckTimer();\r\n    this.sessionCheckTimer = setInterval(\r\n      this.checkSession.bind(this),\r\n      this.sessionCheckIntervall\r\n    );\r\n  }\r\n\r\n  private stopSessionCheckTimer(): void {\r\n    if (this.sessionCheckTimer) {\r\n      clearInterval(this.sessionCheckTimer);\r\n      this.sessionCheckTimer = null;\r\n    }\r\n  }\r\n\r\n  private checkSession(): void {\r\n    const iframe: any = document.getElementById(this.sessionCheckIFrameName);\r\n\r\n    if (!iframe) {\r\n      console.warn(\r\n        'checkSession did not find iframe',\r\n        this.sessionCheckIFrameName\r\n      );\r\n    }\r\n\r\n    const sessionState = this.getSessionState();\r\n\r\n    if (!sessionState) {\r\n      this.stopSessionCheckTimer();\r\n    }\r\n\r\n    const message = this.clientId + ' ' + sessionState;\r\n    iframe.contentWindow.postMessage(message, this.issuer);\r\n  }\r\n\r\n  private createLoginUrl(\r\n    state = '',\r\n    loginHint = '',\r\n    customRedirectUri = '',\r\n    noPrompt = false,\r\n    params: object = {}\r\n  ) {\r\n    const that = this;\r\n\r\n    let redirectUri: string;\r\n\r\n    if (customRedirectUri) {\r\n      redirectUri = customRedirectUri;\r\n    } else {\r\n      redirectUri = this.redirectUri;\r\n    }\r\n\r\n    return this.createAndSaveNonce().then((nonce: any) => {\r\n      if (state) {\r\n        state = nonce + this.config.nonceStateSeparator + state;\r\n      } else {\r\n        state = nonce;\r\n      }\r\n\r\n      if (!this.requestAccessToken && !this.oidc) {\r\n        throw new Error(\r\n          'Either requestAccessToken or oidc or both must be true'\r\n        );\r\n      }\r\n\r\n      if (this.oidc && this.requestAccessToken) {\r\n        this.responseType = 'id_token token';\r\n      } else if (this.oidc && !this.requestAccessToken) {\r\n        this.responseType = 'id_token';\r\n      } else {\r\n        this.responseType = 'token';\r\n      }\r\n\r\n      const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\r\n\r\n      let scope = that.scope;\r\n\r\n      if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\r\n        scope = 'openid ' + scope;\r\n      }\r\n\r\n      let url =\r\n        that.loginUrl +\r\n        seperationChar +\r\n        'response_type=' +\r\n        encodeURIComponent(that.responseType) +\r\n        '&client_id=' +\r\n        encodeURIComponent(that.clientId) +\r\n        '&state=' +\r\n        encodeURIComponent(state) +\r\n        '&redirect_uri=' +\r\n        encodeURIComponent(redirectUri) +\r\n        '&scope=' +\r\n        encodeURIComponent(scope);\r\n\r\n      if (loginHint) {\r\n        url += '&login_hint=' + encodeURIComponent(loginHint);\r\n      }\r\n\r\n      if (that.resource) {\r\n        url += '&resource=' + encodeURIComponent(that.resource);\r\n      }\r\n\r\n      if (that.oidc) {\r\n        url += '&nonce=' + encodeURIComponent(nonce);\r\n      }\r\n\r\n      if (noPrompt) {\r\n        url += '&prompt=none';\r\n      }\r\n\r\n      for (const key of Object.keys(params)) {\r\n        url +=\r\n          '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\r\n      }\r\n\r\n      if (this.customQueryParams) {\r\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n          url +=\r\n            '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\r\n        }\r\n      }\r\n\r\n      return url;\r\n    });\r\n  }\r\n\r\n  initImplicitFlowInternal(\r\n    additionalState = '',\r\n    params: string | object = ''\r\n  ): void {\r\n    if (this.inImplicitFlow) {\r\n      return;\r\n    }\r\n\r\n    this.inImplicitFlow = true;\r\n\r\n    if (!this.validateUrlForHttps(this.loginUrl)) {\r\n      throw new Error(\r\n        'loginUrl must use Http. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    let addParams: object = {};\r\n    let loginHint: string = null;\r\n\r\n    if (typeof params === 'string') {\r\n      loginHint = params;\r\n    } else if (typeof params === 'object') {\r\n      addParams = params;\r\n    }\r\n\r\n    this.createLoginUrl(additionalState, loginHint, null, false, addParams)\r\n      .then(function(url) {\r\n        location.href = url;\r\n      })\r\n      .catch(error => {\r\n        console.error('Error in initImplicitFlow');\r\n        console.error(error);\r\n        this.inImplicitFlow = false;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Starts the implicit flow and redirects to user to\r\n   * the auth servers login url.\r\n   *\r\n   * @param additionalState Optinal state that is passes around.\r\n   *  You find this state in the property ``state`` after ``tryLogin`` logged in the user.\r\n   * @param params Hash with additional parameter. If it is a string, it is used for the\r\n   *               parameter loginHint (for the sake of compatibility with former versions)\r\n   */\r\n  public initImplicitFlow(\r\n    additionalState = '',\r\n    params: string | object = ''\r\n  ): void {\r\n    if (this.loginUrl !== '') {\r\n      this.initImplicitFlowInternal(additionalState, params);\r\n    } else {\r\n      this.events\r\n        .pipe(filter(e => e.type === 'discovery_document_loaded'))\r\n        .subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\r\n    }\r\n  }\r\n\r\n  private callOnTokenReceivedIfExists(options: LoginOptions): void {\r\n    const that = this;\r\n    if (options.onTokenReceived) {\r\n      const tokenParams = {\r\n        idClaims: that.getIdentityClaims(),\r\n        idToken: that.getIdToken(),\r\n        accessToken: that.getAccessToken(),\r\n        state: that.state\r\n      };\r\n      options.onTokenReceived(tokenParams);\r\n    }\r\n  }\r\n\r\n  private storeAccessTokenResponse(\r\n    accessToken: string,\r\n    refreshToken: string,\r\n    expiresIn: number,\r\n    grantedScopes: String\r\n  ): void {\r\n    this._storage.setItem('access_token', accessToken);\r\n    this._storage.setItem(\r\n      'granted_scopes',\r\n      JSON.stringify(grantedScopes.split('+'))\r\n    );\r\n    this._storage.setItem('access_token_stored_at', '' + Date.now());\r\n    if (expiresIn) {\r\n      const expiresInMilliSeconds = expiresIn * 1000;\r\n      const now = new Date();\r\n      const expiresAt = now.getTime() + expiresInMilliSeconds;\r\n      this._storage.setItem('expires_at', '' + expiresAt);\r\n    }\r\n\r\n    if (refreshToken) {\r\n      this._storage.setItem('refresh_token', refreshToken);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks whether there are tokens in the hash fragment\r\n   * as a result of the implicit flow. These tokens are\r\n   * parsed, validated and used to sign the user in to the\r\n   * current client.\r\n   *\r\n   * @param options Optinal options.\r\n   */\r\n  public tryLogin(options: LoginOptions = null): Promise<void> {\r\n    options = options || {};\r\n\r\n    let parts: object;\r\n\r\n    if (options.customHashFragment) {\r\n      parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\r\n    } else {\r\n      parts = this.urlHelper.getHashFragmentParams();\r\n    }\r\n\r\n    this.debug('parsed url', parts);\r\n\r\n    const state = parts['state'];\r\n    let nonceInState = state;\r\n\r\n    if (state) {\r\n      const idx = state.indexOf(this.config.nonceStateSeparator);\r\n\r\n      if (idx > -1) {\r\n        nonceInState = state.substr(0, idx);\r\n        this.state = state.substr(idx + this.config.nonceStateSeparator.length);\r\n      }\r\n    }\r\n\r\n    if (parts['error']) {\r\n      this.debug('error trying to login');\r\n      this.handleLoginError(options, parts);\r\n      const err = new OAuthErrorEvent('token_error', {}, parts);\r\n      this.eventsSubject.next(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    const accessToken = parts['access_token'];\r\n    const idToken = parts['id_token'];\r\n    const sessionState = parts['session_state'];\r\n    const grantedScopes = parts['scope'];\r\n\r\n    if (!this.requestAccessToken && !this.oidc) {\r\n      return Promise.reject(\r\n        'Either requestAccessToken or oidc or both must be true.'\r\n      );\r\n    }\r\n\r\n    if (this.requestAccessToken && !accessToken) {\r\n      return Promise.resolve();\r\n    }\r\n    if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\r\n      return Promise.resolve();\r\n    }\r\n    if (this.oidc && !idToken) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    if (this.sessionChecksEnabled && !sessionState) {\r\n      console.warn(\r\n        'session checks (Session Status Change Notification) ' +\r\n          'is activated in the configuration but the id_token ' +\r\n          'does not contain a session_state claim'\r\n      );\r\n    }\r\n\r\n    if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\r\n      const success = this.validateNonceForAccessToken(\r\n        accessToken,\r\n        nonceInState\r\n      );\r\n      if (!success) {\r\n        const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\r\n        this.eventsSubject.next(event);\r\n        return Promise.reject(event);\r\n      }\r\n    }\r\n\r\n    if (this.requestAccessToken) {\r\n      this.storeAccessTokenResponse(\r\n        accessToken,\r\n        null,\r\n        parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec,\r\n        grantedScopes\r\n      );\r\n    }\r\n\r\n    if (!this.oidc) {\r\n      this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\r\n        location.hash = '';\r\n      }\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return this.processIdToken(idToken, accessToken)\r\n      .then(result => {\r\n        if (options.validationHandler) {\r\n          return options\r\n            .validationHandler({\r\n              accessToken: accessToken,\r\n              idClaims: result.idTokenClaims,\r\n              idToken: result.idToken,\r\n              state: state\r\n            })\r\n            .then(_ => result);\r\n        }\r\n        return result;\r\n      })\r\n      .then(result => {\r\n        this.storeIdToken(result);\r\n        this.storeSessionState(sessionState);\r\n        if (this.clearHashAfterLogin) {\r\n          location.hash = '';\r\n        }\r\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n        this.callOnTokenReceivedIfExists(options);\r\n        this.inImplicitFlow = false;\r\n      })\r\n      .catch(reason => {\r\n        this.eventsSubject.next(\r\n          new OAuthErrorEvent('token_validation_error', reason)\r\n        );\r\n        console.error('Error validating tokens');\r\n        console.error(reason);\r\n        return Promise.reject(reason);\r\n      });\r\n  }\r\n\r\n  private validateNonceForAccessToken(\r\n    accessToken: string,\r\n    nonceInState: string\r\n  ): boolean {\r\n    const savedNonce = this._storage.getItem('nonce');\r\n    if (savedNonce !== nonceInState) {\r\n      const err = 'validating access_token failed. wrong state/nonce.';\r\n      console.error(err, savedNonce, nonceInState);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  protected storeIdToken(idToken: ParsedIdToken) {\r\n    this._storage.setItem('id_token', idToken.idToken);\r\n    this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\r\n    this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\r\n    this._storage.setItem('id_token_stored_at', '' + Date.now());\r\n  }\r\n\r\n  protected storeSessionState(sessionState: string): void {\r\n    this._storage.setItem('session_state', sessionState);\r\n  }\r\n\r\n  protected getSessionState(): string {\r\n    return this._storage.getItem('session_state');\r\n  }\r\n\r\n  private handleLoginError(options: LoginOptions, parts: object): void {\r\n    if (options.onLoginError) {\r\n      options.onLoginError(parts);\r\n    }\r\n    if (this.clearHashAfterLogin) {\r\n      location.hash = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  public processIdToken(\r\n    idToken: string,\r\n    accessToken: string\r\n  ): Promise<ParsedIdToken> {\r\n    const tokenParts = idToken.split('.');\r\n    const headerBase64 = this.padBase64(tokenParts[0]);\r\n    const headerJson = b64DecodeUnicode(headerBase64);\r\n    const header = JSON.parse(headerJson);\r\n    const claimsBase64 = this.padBase64(tokenParts[1]);\r\n    const claimsJson = b64DecodeUnicode(claimsBase64);\r\n    const claims = JSON.parse(claimsJson);\r\n    const savedNonce = this._storage.getItem('nonce');\r\n\r\n    if (Array.isArray(claims.aud)) {\r\n      if (claims.aud.every(v => v !== this.clientId)) {\r\n        const err = 'Wrong audience: ' + claims.aud.join(',');\r\n        console.warn(err);\r\n        return Promise.reject(err);\r\n      }\r\n    } else {\r\n      if (claims.aud !== this.clientId) {\r\n        const err = 'Wrong audience: ' + claims.aud;\r\n        console.warn(err);\r\n        return Promise.reject(err);\r\n      }\r\n    }\r\n\r\n    /*\r\n        if (this.getKeyCount() > 1 && !header.kid) {\r\n            let err = 'There needs to be a kid property in the id_token header when multiple keys are defined via the property jwks';\r\n            console.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        */\r\n\r\n    if (!claims.sub) {\r\n      const err = 'No sub claim in id_token';\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    /* For now, we only check whether the sub against\r\n         * silentRefreshSubject when sessionChecksEnabled is on\r\n         * We will reconsider in a later version to do this\r\n         * in every other case too.\r\n         */\r\n    if (\r\n      this.sessionChecksEnabled &&\r\n      this.silentRefreshSubject &&\r\n      this.silentRefreshSubject !== claims['sub']\r\n    ) {\r\n      const err =\r\n        'After refreshing, we got an id_token for another user (sub). ' +\r\n        `Expected sub: ${this.silentRefreshSubject}, received sub: ${\r\n          claims['sub']\r\n        }`;\r\n\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    if (!claims.iat) {\r\n      const err = 'No iat claim in id_token';\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    if (claims.iss !== this.issuer) {\r\n      const err = 'Wrong issuer: ' + claims.iss;\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    if (claims.nonce !== savedNonce) {\r\n      const err = 'Wrong nonce: ' + claims.nonce;\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    if (\r\n      !this.disableAtHashCheck &&\r\n      this.requestAccessToken &&\r\n      !claims['at_hash']\r\n    ) {\r\n      const err = 'An at_hash is needed!';\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    const now = Date.now();\r\n    const issuedAtMSec = claims.iat * 1000;\r\n    const expiresAtMSec = claims.exp * 1000;\r\n    const tenMinutesInMsec = 1000 * 60 * 10;\r\n\r\n    if (\r\n      issuedAtMSec - tenMinutesInMsec >= now ||\r\n      expiresAtMSec + tenMinutesInMsec <= now\r\n    ) {\r\n      const err = 'Token has been expired';\r\n      console.error(err);\r\n      console.error({\r\n        now: now,\r\n        issuedAtMSec: issuedAtMSec,\r\n        expiresAtMSec: expiresAtMSec\r\n      });\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    const validationParams: ValidationParams = {\r\n      accessToken: accessToken,\r\n      idToken: idToken,\r\n      jwks: this.jwks,\r\n      idTokenClaims: claims,\r\n      idTokenHeader: header,\r\n      loadKeys: () => this.loadJwks()\r\n    };\r\n\r\n    if (\r\n      !this.disableAtHashCheck &&\r\n      this.requestAccessToken &&\r\n      !this.checkAtHash(validationParams)\r\n    ) {\r\n      const err = 'Wrong at_hash';\r\n      console.warn(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    return this.checkSignature(validationParams).then(_ => {\r\n      const result: ParsedIdToken = {\r\n        idToken: idToken,\r\n        idTokenClaims: claims,\r\n        idTokenClaimsJson: claimsJson,\r\n        idTokenHeader: header,\r\n        idTokenHeaderJson: headerJson,\r\n        idTokenExpiresAt: expiresAtMSec\r\n      };\r\n      return result;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the received claims about the user.\r\n   */\r\n  public getIdentityClaims(): object {\r\n    const claims = this._storage.getItem('id_token_claims_obj');\r\n    if (!claims) {\r\n      return null;\r\n    }\r\n    return JSON.parse(claims);\r\n  }\r\n\r\n  /**\r\n   * Returns the granted scopes from the server.\r\n   */\r\n  public getGrantedScopes(): object {\r\n    const scopes = this._storage.getItem('granted_scopes');\r\n    if (!scopes) {\r\n      return null;\r\n    }\r\n    return JSON.parse(scopes);\r\n  }\r\n\r\n  /**\r\n   * Returns the current id_token.\r\n   */\r\n  public getIdToken(): string {\r\n    return this._storage.getItem('id_token');\r\n  }\r\n\r\n  private padBase64(base64data): string {\r\n    while (base64data.length % 4 !== 0) {\r\n      base64data += '=';\r\n    }\r\n    return base64data;\r\n  }\r\n\r\n  /**\r\n   * Returns the current access_token.\r\n   */\r\n  public getAccessToken(): string {\r\n    return this._storage.getItem('access_token');\r\n  }\r\n\r\n  public getRefreshToken(): string {\r\n    return this._storage.getItem('refresh_token');\r\n  }\r\n\r\n  /**\r\n   * Returns the expiration date of the access_token\r\n   * as milliseconds since 1970.\r\n   */\r\n  public getAccessTokenExpiration(): number {\r\n    if (!this._storage.getItem('expires_at')) {\r\n      return null;\r\n    }\r\n    return parseInt(this._storage.getItem('expires_at'), 10);\r\n  }\r\n\r\n  private getAccessTokenStoredAt(): number {\r\n    return parseInt(this._storage.getItem('access_token_stored_at'), 10);\r\n  }\r\n\r\n  private getIdTokenStoredAt(): number {\r\n    return parseInt(this._storage.getItem('id_token_stored_at'), 10);\r\n  }\r\n\r\n  /**\r\n   * Returns the expiration date of the id_token\r\n   * as milliseconds since 1970.\r\n   */\r\n  public getIdTokenExpiration(): number {\r\n    if (!this._storage.getItem('id_token_expires_at')) {\r\n      return null;\r\n    }\r\n\r\n    return parseInt(this._storage.getItem('id_token_expires_at'), 10);\r\n  }\r\n\r\n  /**\r\n   * Checkes, whether there is a valid access_token.\r\n   */\r\n  public hasValidAccessToken(): boolean {\r\n    if (this.getAccessToken()) {\r\n      const expiresAt = this._storage.getItem('expires_at');\r\n      const now = new Date();\r\n      if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checkes, whether there is a valid id_token.\r\n   */\r\n  public hasValidIdToken(): boolean {\r\n    if (this.getIdToken()) {\r\n      const expiresAt = this._storage.getItem('id_token_expires_at');\r\n      const now = new Date();\r\n      if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns the auth-header that can be used\r\n   * to transmit the access_token to a service\r\n   */\r\n  public authorizationHeader(): string {\r\n    return 'Bearer ' + this.getAccessToken();\r\n  }\r\n\r\n  /**\r\n   * Removes all tokens and logs the user out.\r\n   * If a logout url is configured, the user is\r\n   * redirected to it.\r\n   * @param noRedirectToLogoutUrl\r\n   */\r\n  public logOut(noRedirectToLogoutUrl = false): void {\r\n    const id_token = this.getIdToken();\r\n    this._storage.removeItem('access_token');\r\n    this._storage.removeItem('id_token');\r\n    this._storage.removeItem('refresh_token');\r\n    this._storage.removeItem('nonce');\r\n    this._storage.removeItem('expires_at');\r\n    this._storage.removeItem('id_token_claims_obj');\r\n    this._storage.removeItem('id_token_expires_at');\r\n    this._storage.removeItem('id_token_stored_at');\r\n    this._storage.removeItem('access_token_stored_at');\r\n    this._storage.removeItem('granted_scopes');\r\n    this._storage.removeItem('session_state');\r\n\r\n    this.silentRefreshSubject = null;\r\n\r\n    this.eventsSubject.next(new OAuthInfoEvent('logout'));\r\n\r\n    if (!this.logoutUrl) {\r\n      return;\r\n    }\r\n    if (noRedirectToLogoutUrl) {\r\n      return;\r\n    }\r\n    if (!id_token) {\r\n      return;\r\n    }\r\n\r\n    let logoutUrl: string;\r\n\r\n    if (!this.validateUrlForHttps(this.logoutUrl)) {\r\n      throw new Error(\r\n        'logoutUrl must use Http. Also check property requireHttps.'\r\n      );\r\n    }\r\n\r\n    // For backward compatibility\r\n    if (this.logoutUrl.indexOf('{{') > -1) {\r\n      logoutUrl = this.logoutUrl\r\n        .replace(/\\{\\{id_token\\}\\}/, id_token)\r\n        .replace(/\\{\\{client_id\\}\\}/, this.clientId);\r\n    } else {\r\n      logoutUrl =\r\n        this.logoutUrl +\r\n        (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\r\n        'id_token_hint=' +\r\n        encodeURIComponent(id_token) +\r\n        '&post_logout_redirect_uri=' +\r\n        encodeURIComponent(this.postLogoutRedirectUri || this.redirectUri);\r\n    }\r\n    location.href = logoutUrl;\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  public createAndSaveNonce(): Promise<string> {\r\n    const that = this;\r\n    return this.createNonce().then(function(nonce: any) {\r\n      that._storage.setItem('nonce', nonce);\r\n      return nonce;\r\n    });\r\n  }\r\n\r\n  protected createNonce(): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.rngUrl) {\r\n        throw new Error(\r\n          'createNonce with rng-web-api has not been implemented so far'\r\n        );\r\n      } else {\r\n        let text = '';\r\n        const possible =\r\n          'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n\r\n        for (let i = 0; i < 40; i++) {\r\n          text += possible.charAt(Math.floor(Math.random() * possible.length));\r\n        }\r\n\r\n        resolve(text);\r\n      }\r\n    });\r\n  }\r\n\r\n  private checkAtHash(params: ValidationParams): boolean {\r\n    if (!this.tokenValidationHandler) {\r\n      console.warn(\r\n        'No tokenValidationHandler configured. Cannot check at_hash.'\r\n      );\r\n      return true;\r\n    }\r\n    return this.tokenValidationHandler.validateAtHash(params);\r\n  }\r\n\r\n  private checkSignature(params: ValidationParams): Promise<any> {\r\n    if (!this.tokenValidationHandler) {\r\n      console.warn(\r\n        'No tokenValidationHandler configured. Cannot check signature.'\r\n      );\r\n      return Promise.resolve(null);\r\n    }\r\n    return this.tokenValidationHandler.validateSignature(params);\r\n  }\r\n}\r\n",
    "export abstract class OAuthModuleConfig {\r\n  resourceServer: OAuthResourceServerConfig;\r\n}\r\n\r\nexport abstract class OAuthResourceServerConfig {\r\n  /**\r\n   * Urls for which calls should be intercepted.\r\n   * If there is an ResourceServerErrorHandler registered, it is used for them.\r\n   * If sendAccessToken is set to true, the access_token is send to them too.\r\n   */\r\n  allowedUrls: Array<string>;\r\n  sendAccessToken: boolean;\r\n}\r\n",
    "import { HttpResponse } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\n\r\nexport abstract class OAuthResourceServerErrorHandler {\r\n  abstract handleError(err: HttpResponse<any>): Observable<any>;\r\n}\r\n\r\nexport class OAuthNoopResourceServerErrorHandler\r\n  implements OAuthResourceServerErrorHandler {\r\n  handleError(err: HttpResponse<any>): Observable<any> {\r\n    return throwError(err);\r\n  }\r\n}\r\n",
    "import { Injectable, Inject, Optional } from '@angular/core';\r\nimport { OAuthService } from '../oauth-service';\r\nimport { OAuthStorage } from '../types';\r\nimport {\r\n  HttpEvent,\r\n  HttpHandler,\r\n  HttpInterceptor,\r\n  HttpRequest,\r\n  HttpResponse,\r\n  HttpErrorResponse\r\n} from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { catchError } from 'rxjs/operators';\r\nimport { OAuthResourceServerErrorHandler } from './resource-server-error-handler';\r\nimport { OAuthModuleConfig } from '../oauth-module.config';\r\n\r\n@Injectable()\r\nexport class DefaultOAuthInterceptor implements HttpInterceptor {\r\n  constructor(\r\n    private authStorage: OAuthStorage,\r\n    private errorHandler: OAuthResourceServerErrorHandler,\r\n    @Optional() private moduleConfig: OAuthModuleConfig\r\n  ) {}\r\n\r\n  private checkUrl(url: string): boolean {\r\n    const found = this.moduleConfig.resourceServer.allowedUrls.find(u =>\r\n      url.startsWith(u)\r\n    );\r\n    return !!found;\r\n  }\r\n\r\n  public intercept(\r\n    req: HttpRequest<any>,\r\n    next: HttpHandler\r\n  ): Observable<HttpEvent<any>> {\r\n    const url = req.url.toLowerCase();\r\n\r\n    if (!this.moduleConfig) {\r\n      return next.handle(req);\r\n    }\r\n    if (!this.moduleConfig.resourceServer) {\r\n      return next.handle(req);\r\n    }\r\n    if (!this.moduleConfig.resourceServer.allowedUrls) {\r\n      return next.handle(req);\r\n    }\r\n    if (!this.checkUrl(url)) {\r\n      return next.handle(req);\r\n    }\r\n\r\n    const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\r\n\r\n    if (sendAccessToken && this.authStorage.getItem('access_token')) {\r\n      const token = this.authStorage.getItem('access_token');\r\n      const header = 'Bearer ' + token;\r\n\r\n      const headers = req.headers.set('Authorization', header);\r\n\r\n      req = req.clone({ headers });\r\n    }\r\n\r\n    return next\r\n      .handle(req)\r\n      .pipe(catchError(err => this.errorHandler.handleError(err)));\r\n  }\r\n}\r\n",
    "import { ValidationHandler, ValidationParams } from './validation-handler';\r\n\r\n/**\r\n * A validation handler that isn't validating nothing.\r\n * Can be used to skip validation (on your own risk).\r\n */\r\nexport class NullValidationHandler implements ValidationHandler {\r\n  validateSignature(validationParams: ValidationParams): Promise<any> {\r\n    return Promise.resolve(null);\r\n  }\r\n  validateAtHash(validationParams: ValidationParams): boolean {\r\n    return true;\r\n  }\r\n}\r\n",
    "import { OAuthStorage } from './types';\r\nimport { NgModule, ModuleWithProviders } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';\r\n\r\nimport { OAuthService } from './oauth-service';\r\nimport { UrlHelperService } from './url-helper.service';\r\n\r\nimport { OAuthModuleConfig } from './oauth-module.config';\r\nimport {\r\n  OAuthResourceServerErrorHandler,\r\n  OAuthNoopResourceServerErrorHandler\r\n} from './interceptors/resource-server-error-handler';\r\nimport { DefaultOAuthInterceptor } from './interceptors/default-oauth.interceptor';\r\nimport { ValidationHandler } from './token-validation/validation-handler';\r\nimport { NullValidationHandler } from './token-validation/null-validation-handler';\r\n\r\nexport function createDefaultStorage() {\r\n  return typeof sessionStorage !== 'undefined' ? sessionStorage : null;\r\n}\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class OAuthModule {\r\n  static forRoot(\r\n    config: OAuthModuleConfig = null,\r\n    validationHandlerClass = NullValidationHandler\r\n  ): ModuleWithProviders {\r\n    // const setupInterceptor = config && config.resourceServer && config.resourceServer.allowedUrls;\r\n\r\n    return {\r\n      ngModule: OAuthModule,\r\n      providers: [\r\n        OAuthService,\r\n        UrlHelperService,\r\n        { provide: OAuthStorage, useFactory: createDefaultStorage },\r\n        { provide: ValidationHandler, useClass: validationHandlerClass},\r\n        {\r\n          provide: OAuthResourceServerErrorHandler,\r\n          useClass: OAuthNoopResourceServerErrorHandler\r\n        },\r\n        { provide: OAuthModuleConfig, useValue: config },\r\n        {\r\n          provide: HTTP_INTERCEPTORS,\r\n          useClass: DefaultOAuthInterceptor,\r\n          multi: true\r\n        }\r\n      ]\r\n    };\r\n  }\r\n}\r\n",
    "import {\r\n  AbstractValidationHandler,\r\n  ValidationParams\r\n} from './validation-handler';\r\n\r\n// declare var require: any;\r\n// let rs = require('jsrsasign');\r\n\r\nimport * as rs from 'jsrsasign';\r\n\r\n/**\r\n * Validates the signature of an id_token against one\r\n * of the keys of an JSON Web Key Set (jwks).\r\n *\r\n * This jwks can be provided by the discovery document.\r\n */\r\nexport class JwksValidationHandler extends AbstractValidationHandler {\r\n  /**\r\n   * Allowed algorithms\r\n   */\r\n  allowedAlgorithms: string[] = [\r\n    'HS256',\r\n    'HS384',\r\n    'HS512',\r\n    'RS256',\r\n    'RS384',\r\n    'RS512',\r\n    'ES256',\r\n    'ES384',\r\n    'PS256',\r\n    'PS384',\r\n    'PS512'\r\n  ];\r\n\r\n  /**\r\n   * Time period in seconds the timestamp in the signature can\r\n   * differ from the current time.\r\n   */\r\n  gracePeriodInSec = 600;\r\n\r\n  validateSignature(params: ValidationParams, retry = false): Promise<any> {\r\n    if (!params.idToken) throw new Error('Parameter idToken expected!');\r\n    if (!params.idTokenHeader)\r\n      throw new Error('Parameter idTokenHandler expected.');\r\n    if (!params.jwks) throw new Error('Parameter jwks expected!');\r\n\r\n    if (\r\n      !params.jwks['keys'] ||\r\n      !Array.isArray(params.jwks['keys']) ||\r\n      params.jwks['keys'].length === 0\r\n    ) {\r\n      throw new Error('Array keys in jwks missing!');\r\n    }\r\n\r\n    // console.debug('validateSignature: retry', retry);\r\n\r\n    let kid: string = params.idTokenHeader['kid'];\r\n    let keys: object[] = params.jwks['keys'];\r\n    let key: object;\r\n\r\n    let alg = params.idTokenHeader['alg'];\r\n\r\n    if (kid) {\r\n      key = keys.find(k => k['kid'] === kid /* && k['use'] === 'sig' */);\r\n    } else {\r\n      let kty = this.alg2kty(alg);\r\n      let matchingKeys = keys.filter(\r\n        k => k['kty'] === kty && k['use'] === 'sig'\r\n      );\r\n\r\n      /*\r\n            if (matchingKeys.length == 0) {\r\n                let error = 'No matching key found.';\r\n                console.error(error);\r\n                return Promise.reject(error);\r\n            }*/\r\n      if (matchingKeys.length > 1) {\r\n        let error =\r\n          'More than one matching key found. Please specify a kid in the id_token header.';\r\n        console.error(error);\r\n        return Promise.reject(error);\r\n      } else if (matchingKeys.length === 1) {\r\n        key = matchingKeys[0];\r\n      }\r\n    }\r\n\r\n    if (!key && !retry && params.loadKeys) {\r\n      return params\r\n        .loadKeys()\r\n        .then(loadedKeys => (params.jwks = loadedKeys))\r\n        .then(_ => this.validateSignature(params, true));\r\n    }\r\n\r\n    if (!key && retry && !kid) {\r\n      let error = 'No matching key found.';\r\n      console.error(error);\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    if (!key && retry && kid) {\r\n      let error =\r\n        'expected key not found in property jwks. ' +\r\n        'This property is most likely loaded with the ' +\r\n        'discovery document. ' +\r\n        'Expected key id (kid): ' +\r\n        kid;\r\n\r\n      console.error(error);\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    let keyObj = rs.KEYUTIL.getKey(key);\r\n    let validationOptions = {\r\n      alg: this.allowedAlgorithms,\r\n      gracePeriod: this.gracePeriodInSec\r\n    };\r\n    let isValid = rs.KJUR.jws.JWS.verifyJWT(\r\n      params.idToken,\r\n      keyObj,\r\n      validationOptions\r\n    );\r\n\r\n    if (isValid) {\r\n      return Promise.resolve();\r\n    } else {\r\n      return Promise.reject('Signature not valid');\r\n    }\r\n  }\r\n\r\n  private alg2kty(alg: string) {\r\n    switch (alg.charAt(0)) {\r\n      case 'R':\r\n        return 'RSA';\r\n      case 'E':\r\n        return 'EC';\r\n      default:\r\n        throw new Error('Cannot infer kty from alg: ' + alg);\r\n    }\r\n  }\r\n\r\n  calcHash(valueToHash: string, algorithm: string): string {\r\n    let hashAlg = new rs.KJUR.crypto.MessageDigest({ alg: algorithm });\r\n    let result = hashAlg.digestString(valueToHash);\r\n    let byteArrayAsString = this.toByteArrayAsString(result);\r\n    return byteArrayAsString;\r\n  }\r\n\r\n  toByteArrayAsString(hexString: string) {\r\n    let result = '';\r\n    for (let i = 0; i < hexString.length; i += 2) {\r\n      let hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\r\n      let num = parseInt(hexDigit, 16);\r\n      result += String.fromCharCode(num);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n",
    "import { InjectionToken } from '@angular/core';\r\nimport { AuthConfig } from './auth.config';\r\n\r\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>('AUTH_CONFIG');\r\n"
  ],
  "names": [
    "extendStatics",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__extends",
    "__",
    "this",
    "constructor",
    "prototype",
    "create",
    "__values",
    "o",
    "m",
    "Symbol",
    "iterator",
    "i",
    "call",
    "next",
    "length",
    "value",
    "done",
    "__read",
    "n",
    "r",
    "e",
    "ar",
    "push",
    "error",
    "LoginOptions",
    "preventClearHashAfterLogin",
    "OAuthStorage",
    "ReceivedTokens",
    "ValidationHandler",
    "AbstractValidationHandler",
    "validateAtHash",
    "params",
    "hashAlg",
    "inferHashAlgorithm",
    "idTokenHeader",
    "tokenHash",
    "calcHash",
    "accessToken",
    "leftMostHalf",
    "substr",
    "atHash",
    "btoa",
    "replace",
    "claimsAtHash",
    "idTokenClaims",
    "console",
    "jwtHeader",
    "alg",
    "match",
    "Error",
    "UrlHelperService",
    "getHashFragmentParams",
    "customHashFragment",
    "hash",
    "window",
    "location",
    "decodeURIComponent",
    "indexOf",
    "questionMarkPosition",
    "parseQueryString",
    "queryString",
    "pairs",
    "pair",
    "separatorIndex",
    "escapedKey",
    "escapedValue",
    "key",
    "data",
    "split",
    "type",
    "Injectable",
    "OAuthEvent",
    "OAuthSuccessEvent",
    "_super",
    "info",
    "_this",
    "tslib_1.__extends",
    "OAuthInfoEvent",
    "OAuthErrorEvent",
    "reason",
    "b64DecodeUnicode",
    "str",
    "base64",
    "atob",
    "map",
    "c",
    "charCodeAt",
    "toString",
    "slice",
    "join",
    "AuthConfig",
    "json",
    "clientId",
    "redirectUri",
    "postLogoutRedirectUri",
    "loginUrl",
    "scope",
    "resource",
    "rngUrl",
    "oidc",
    "requestAccessToken",
    "options",
    "issuer",
    "logoutUrl",
    "clearHashAfterLogin",
    "tokenEndpoint",
    "userinfoEndpoint",
    "responseType",
    "showDebugInformation",
    "silentRefreshRedirectUri",
    "silentRefreshMessagePrefix",
    "silentRefreshShowIFrame",
    "siletRefreshTimeout",
    "silentRefreshTimeout",
    "dummyClientSecret",
    "requireHttps",
    "strictDiscoveryDocumentValidation",
    "jwks",
    "customQueryParams",
    "silentRefreshIFrameName",
    "timeoutFactor",
    "sessionChecksEnabled",
    "sessionCheckIntervall",
    "sessionCheckIFrameUrl",
    "sessionCheckIFrameName",
    "disableAtHashCheck",
    "skipSubjectCheck",
    "useIdTokenHintForSilentRefresh",
    "skipIssuerCheck",
    "nonceStateSeparator",
    "useHttpBasicAuthForPasswordFlow",
    "openUri",
    "uri",
    "href",
    "assign",
    "WebHttpUrlEncodingCodec",
    "encodeKey",
    "k",
    "encodeURIComponent",
    "encodeValue",
    "v",
    "decodeKey",
    "decodeValue",
    "OAuthService",
    "ngZone",
    "http",
    "storage",
    "tokenValidationHandler",
    "config",
    "urlHelper",
    "discoveryDocumentLoaded",
    "state",
    "eventsSubject",
    "Subject",
    "discoveryDocumentLoadedSubject",
    "grantTypesSupported",
    "inImplicitFlow",
    "discoveryDocumentLoaded$",
    "asObservable",
    "events",
    "configure",
    "setStorage",
    "sessionStorage",
    "setupRefreshTimer",
    "setupSessionCheck",
    "configChanged",
    "restartSessionChecksIfStillLoggedIn",
    "hasValidIdToken",
    "initSessionCheck",
    "restartRefreshTimerIfStillLoggedIn",
    "setupExpirationTimers",
    "pipe",
    "filter",
    "subscribe",
    "setupAutomaticSilentRefresh",
    "silentRefresh",
    "catch",
    "_",
    "debug",
    "loadDiscoveryDocumentAndTryLogin",
    "loadDiscoveryDocument",
    "then",
    "doc",
    "tryLogin",
    "loadDiscoveryDocumentAndLogin",
    "hasValidAccessToken",
    "initImplicitFlow",
    "args",
    "_i",
    "arguments",
    "apply",
    "validateUrlFromDiscoveryDocument",
    "url",
    "errors",
    "httpsCheck",
    "validateUrlForHttps",
    "issuerCheck",
    "validateUrlAgainstIssuer",
    "lcUrl",
    "toLowerCase",
    "startsWith",
    "clearAccessTokenTimer",
    "clearIdTokenTimer",
    "idTokenExp",
    "getIdTokenExpiration",
    "Number",
    "MAX_VALUE",
    "useAccessTokenExp",
    "getAccessTokenExpiration",
    "setupAccessTokenTimer",
    "setupIdTokenTimer",
    "expiration",
    "storedAt",
    "getAccessTokenStoredAt",
    "timeout",
    "calcTimeout",
    "runOutsideAngular",
    "accessTokenTimeoutSubscription",
    "of",
    "delay",
    "run",
    "getIdTokenStoredAt",
    "idTokenTimeoutSubscription",
    "unsubscribe",
    "_storage",
    "fullUrl",
    "Promise",
    "resolve",
    "reject",
    "endsWith",
    "get",
    "validateDiscoveryDocument",
    "authorization_endpoint",
    "end_session_endpoint",
    "grant_types_supported",
    "token_endpoint",
    "userinfo_endpoint",
    "jwksUri",
    "jwks_uri",
    "check_session_iframe",
    "loadJwks",
    "event",
    "discoveryDocument",
    "err",
    "warn",
    "fetchTokenUsingPasswordFlowAndLoadUserProfile",
    "userName",
    "password",
    "headers",
    "HttpHeaders",
    "fetchTokenUsingPasswordFlow",
    "loadUserProfile",
    "set",
    "getAccessToken",
    "existingClaims",
    "getIdentityClaims",
    "sub",
    "setItem",
    "JSON",
    "stringify",
    "HttpParams",
    "encoder",
    "header",
    "_a",
    "tslib_1.__values",
    "getOwnPropertyNames",
    "_b",
    "post",
    "tokenResponse",
    "storeAccessTokenResponse",
    "access_token",
    "refresh_token",
    "expires_in",
    "refreshToken",
    "getItem",
    "removeSilentRefreshEventListener",
    "silentRefreshPostMessageEventListener",
    "removeEventListener",
    "setupSilentRefreshEventListener",
    "expectedPrefix",
    "prefixedMessage",
    "message",
    "onLoginError",
    "onTokenReceived",
    "addEventListener",
    "noPrompt",
    "claims",
    "getIdToken",
    "document",
    "existingIframe",
    "getElementById",
    "body",
    "removeChild",
    "silentRefreshSubject",
    "iframe",
    "createElement",
    "id",
    "createLoginUrl",
    "setAttribute",
    "style",
    "appendChild",
    "first",
    "success",
    "race",
    "tap",
    "toPromise",
    "canPerformSessionCheck",
    "getSessionState",
    "setupSessionCheckEventListener",
    "removeSessionCheckEventListener",
    "sessionCheckEventListener",
    "origin",
    "handleSessionUnchanged",
    "handleSessionChange",
    "handleSessionError",
    "stopSessionCheckTimer",
    "waitForSilentRefreshAfterSessionChange",
    "logOut",
    "display",
    "startSessionCheckTimer",
    "sessionCheckTimer",
    "setInterval",
    "checkSession",
    "bind",
    "clearInterval",
    "sessionState",
    "contentWindow",
    "postMessage",
    "loginHint",
    "customRedirectUri",
    "that",
    "createAndSaveNonce",
    "nonce",
    "seperationChar",
    "keys",
    "_d",
    "_e",
    "initImplicitFlowInternal",
    "additionalState",
    "addParams",
    "callOnTokenReceivedIfExists",
    "tokenParams",
    "idClaims",
    "idToken",
    "expiresIn",
    "grantedScopes",
    "Date",
    "now",
    "expiresInMilliSeconds",
    "expiresAt",
    "getTime",
    "parts",
    "nonceInState",
    "idx",
    "handleLoginError",
    "disableOAuth2StateCheck",
    "validateNonceForAccessToken",
    "fallbackAccessTokenExpirationTimeInSec",
    "processIdToken",
    "result",
    "validationHandler",
    "storeIdToken",
    "storeSessionState",
    "savedNonce",
    "idTokenClaimsJson",
    "idTokenExpiresAt",
    "tokenParts",
    "headerJson",
    "padBase64",
    "parse",
    "claimsJson",
    "isArray",
    "aud",
    "every",
    "iat",
    "iss",
    "issuedAtMSec",
    "expiresAtMSec",
    "exp",
    "validationParams",
    "loadKeys",
    "checkAtHash",
    "checkSignature",
    "idTokenHeaderJson",
    "getGrantedScopes",
    "scopes",
    "base64data",
    "getRefreshToken",
    "parseInt",
    "authorizationHeader",
    "noRedirectToLogoutUrl",
    "id_token",
    "removeItem",
    "createNonce",
    "text",
    "possible",
    "charAt",
    "Math",
    "floor",
    "random",
    "validateSignature",
    "NgZone",
    "HttpClient",
    "decorators",
    "Optional",
    "OAuthModuleConfig",
    "OAuthResourceServerConfig",
    "OAuthResourceServerErrorHandler",
    "OAuthNoopResourceServerErrorHandler",
    "handleError",
    "throwError",
    "DefaultOAuthInterceptor",
    "authStorage",
    "errorHandler",
    "moduleConfig",
    "checkUrl",
    "resourceServer",
    "allowedUrls",
    "find",
    "u",
    "intercept",
    "req",
    "handle",
    "sendAccessToken",
    "clone",
    "catchError",
    "NullValidationHandler",
    "createDefaultStorage",
    "OAuthModule",
    "forRoot",
    "validationHandlerClass",
    "ngModule",
    "providers",
    "provide",
    "useFactory",
    "useClass",
    "useValue",
    "HTTP_INTERCEPTORS",
    "multi",
    "NgModule",
    "imports",
    "CommonModule",
    "declarations",
    "exports",
    "JwksValidationHandler",
    "concat",
    "allowedAlgorithms",
    "gracePeriodInSec",
    "retry",
    "kid",
    "kty_1",
    "alg2kty",
    "matchingKeys",
    "loadedKeys",
    "keyObj",
    "rs.KEYUTIL",
    "getKey",
    "validationOptions",
    "gracePeriod",
    "rs.KJUR",
    "jws",
    "JWS",
    "verifyJWT",
    "valueToHash",
    "algorithm",
    "crypto",
    "MessageDigest",
    "digestString",
    "toByteArrayAsString",
    "hexString",
    "hexDigit",
    "num",
    "String",
    "fromCharCode",
    "AUTH_CONFIG",
    "InjectionToken"
  ],
  "mappings": "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"
}
